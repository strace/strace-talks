% Copyright (C) 2012-2020 Dmitry V. Levin <ldv@altlinux.org>
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.

\documentclass[unicode,aspectratio=169,xcolor={table,dvipsnames,usernames}]{beamer}


\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{alltt}
\usepackage{hyperref}

\colorlet{darkred}{BrickRed}
\colorlet{darkgreen}{OliveGreen}

\pgfdeclareimage[height=2cm]{title-logo}{devconfcz.pdf}
\pgfdeclareimage[height=0.6cm]{left-corner-logo}{basealt.jpg}
\pgfdeclareimage[height=1.2cm]{right-corner-logo}{strace-straus.pdf}
\pgfdeclareimage[height=5.8cm]{wat}{wat.pdf}
\pgfdeclareimage[height=7cm]{kaleidoscope}{kaleidoscope.jpg}
\pgfdeclareimage[height=3cm]{indan}{indan.jpg}
\pgfdeclareimage[height=3cm]{linus}{linus.jpg}
\pgfdeclareimage[height=3cm]{hpa}{hpa.jpg}
\pgfdeclareimage[height=3cm]{roland}{roland.jpg}
\pgfdeclareimage[height=3cm]{denys}{denys.jpg}
\pgfdeclareimage[height=3cm]{oleg}{oleg.jpg}
\pgfdeclareimage[height=3cm]{pedro}{pedro.jpg}
\pgfdeclareimage[height=3cm]{andy}{andy.jpg}
\pgfdeclareimage[height=3cm]{lp}{lp.jpg}
\pgfdeclareimage[height=2cm]{paul}{paul.jpg}
\pgfdeclareimage[height=2cm]{andrew}{andrew.jpg}
\pgfdeclareimage[height=8cm]{strace-logo}{strace-straus.pdf}
\pgfdeclareimage[height=8cm]{linux-logo}{tux.png}

\usetheme{Warsaw}
\setbeamertemplate{headline}{}
\setbeamertemplate{footline}{%
	\pgfuseimage{left-corner-logo}%
	\hfill%
	\pgfuseimage{right-corner-logo}%
}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{logo}{}
\setbeamercovered{transparent}

\title{\Huge The history \\ of a linux kernel design flaw}
\author{\Huge Dmitry~Levin}
\date{\Large Brno, 2020}
\titlegraphic{\pgfuseimage{title-logo}}

\begin{document}

%%%%%%%
\begin{frame}[noframenumbering]
\titlepage
\end{frame}

%%%%%%%
\begin{frame}{x86-64 architecture in Linux kernel \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Operating modes}
\begin{description}
	\item[64-bit mode]: CS register value == 0x33
	\item[32-bit mode]: CS register value == 0x23
\end{description}
\end{block}

\begin{block}{Several methods of system call invocation}
\begin{description}
	\item[int 0x80]: Legacy 32-bit
	\item[sysenter]: Fast 32-bit
	\item[syscall]: 64-bit
\end{description}
\end{block}

Surprise: 64-bit processes can invoke both 64-bit and 32-bit system calls.

\begin{block}{Linux API provides}
\begin{itemize}
	\item The system call number
	\item The value of CS register
	\item The value of RIP register
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}{Linux system call debuggers and tracers on x86-64 architecture \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Legacy method of obtaining system call information}
\begin{itemize}
	\item Fetch the system call number (PTRACE\_PEEKUSER ORIG\_RAX)
	\item Fetch the value of CS register (PTRACE\_PEEKUSER CS)
	\item {\bf Guess the system call bitness by the value of CS register}
	\item Determine the system call by its number and bitness
	\item Fetch the system call arguments accordingly
\end{itemize}
\end{block}

\begin{block}{Traditional method of obtaining system call information}
\begin{itemize}
	\item Fetch the whole set of registers (PTRACE\_GETREGSET NT\_PRSTATUS), \\
		the return value is decided by the value of CS register
	\item {\bf Guess the system call bitness by the return value}
	\item Determine the system call by its number and bitness
	\item Interpret other registers as the system call arguments accordingly
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: problem \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Example based on Debian bug report \#459820 submitted in 2008}
\begin{alltt}
#include <stdio.h>
#include <unistd.h>
int main() \{
    setlinebuf(stdout);
    puts("------------");
    \textcolor{darkred}{__asm__("movl $2, %eax; int $0x80");}
    printf("[I am %d]{\textbackslash}n", getpid());
    return 0;
\}
\end{alltt}
\end{block}

\begin{block}{Regular invocation: ./debbug459820}
\begin{alltt}
------------
[I am 23450]
[I am 23451]
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: problem \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{columns}
	\column{10cm}
		\Large
		\begin{block}{Invocation under strace}
\begin{alltt}
$ strace -f ./debbug459820 > /dev/null
\ldots
write(1, "------------{\textbackslash}n", 13) = 13
strace: Process 23451 attached
\textcolor{darkred}{open(0x1, O_RDONLY|O_CREAT|O_TRUNC
|O_DSYNC|O_DIRECT|O_NOATIME|O_CLOEXEC
|O_PATH|O_TMPFILE|0x1000020, 0134300)
= 23451}
\ldots
\end{alltt}
		\end{block}
	\column{3cm}
\end{columns}
\end{frame}

%%%%%%%
{
\begin{frame}[fragile,noframenumbering]{Process bitness does not match syscall bitness: problem \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{columns}
	\column{10cm}
		\Large
		\begin{block}{Invocation under strace}
\begin{alltt}
$ strace -f ./debbug459820 > /dev/null
\ldots
write(1, "------------{\textbackslash}n", 13) = 13
strace: Process 23451 attached
\textcolor{darkred}{open(0x1, O_RDONLY|O_CREAT|O_TRUNC
|O_DSYNC|O_DIRECT|O_NOATIME|O_CLOEXEC
|O_PATH|O_TMPFILE|0x1000020, 0134300)
= 23451}
\ldots
\end{alltt}
		\end{block}
	\column{3cm}
		\begin{figure}
			\centering
			\pgfuseimage{wat}
		\end{figure}
\end{columns}
\end{frame}
}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: problem \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{Invocation under strace: strace -f -z ./debbug459820 > /dev/null}
\begin{alltt}
write(1, "------------{\textbackslash}n", 13)          = 13
strace: Process 23451 attached
\textcolor{darkred}{open(0x1, O_RDONLY|O_CREAT|O_TRUNC|O_DSYNC|O_DIRECT
|O_NOATIME|O_CLOEXEC|O_PATH|O_TMPFILE|0x1000020,
0134300) = 23451}
[pid 23450] getpid()                    = 23450
[pid 23451] getpid()                    = 23451
[pid 23450] write(1, "[I am 23450]{\textbackslash}n", 13) = 13
[pid 23451] write(1, "[I am 23451]{\textbackslash}n", 13) = 13
[pid 23450] +++ exited with 0 +++
+++ exited with 0 +++
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: problem \hfill [\insertframenumber/\inserttotalframenumber]}
\scriptsize
\begin{columns}
	\column{11cm}
		\begin{block}{for i in `seq 0 9`; do strace -qq -esignal=none -eopen ./debbug459820 >/dev/null; done}
		%\textcolor{blue}{\(\longrightarrow\)}
\begin{alltt}
open(0x1, O_RDONLY|O_CREAT|O_EXCL|O_TRUNC|O_SYNC|O_DIRECT|O_LARGEFILE|
          O_NOFOLLOW|O_CLOEXEC|0x4f000008, 0151330) = 15565
open(0x1, O_RDONLY|O_EXCL|O_NOCTTY|O_APPEND|O_NONBLOCK|O_DSYNC|O_TMPFILE|
          FASYNC|0x57800008, 036630) = 15570
open(0x1, O_RDONLY|O_EXCL|O_NOCTTY|O_APPEND|O_SYNC|O_LARGEFILE|O_NOATIME|
          O_PATH|O_DIRECTORY|FASYNC|0x8e800038) = 15575
open(0x1, O_RDONLY|O_CREAT|O_EXCL|O_APPEND|O_DSYNC|O_DIRECT|O_NOFOLLOW|
          O_PATH|O_DIRECTORY|FASYNC|0xe2800018, 072350) = 15580
open(0x1, O_RDONLY|O_CREAT|O_NOCTTY|O_SYNC|O_NOFOLLOW|O_CLOEXEC|FASYNC|
          0xcf800038, 030610) = 15585
open(0x1, O_RDONLY|O_TRUNC|O_NOFOLLOW|O_CLOEXEC|O_DIRECTORY|FASYNC|
          0x11800008) = 15590
open(0x1, O_RDONLY|O_CREAT|O_EXCL|O_NOCTTY|__O_SYNC|O_LARGEFILE|O_NOATIME|
          O_CLOEXEC|O_PATH|O_TMPFILE|FASYNC|0x43000038, 0121010) = 15595
open(0x1, O_RDONLY|O_EXCL|O_NONBLOCK|__O_SYNC|O_DIRECT|O_CLOEXEC|O_PATH|
          __O_TMPFILE|FASYNC|0x3a800038, 064310) = 15600
open(0x1, O_RDONLY|O_CREAT|O_EXCL|O_NOCTTY|O_NONBLOCK|O_DSYNC|O_DIRECT|
          O_LARGEFILE|O_DIRECTORY|0x47800028, 0154770) = 15610
open(0x1, O_RDONLY|O_NOFOLLOW|O_CLOEXEC|O_PATH|FASYNC|0x5e000008) = 15605
\end{alltt}
		\end{block}
	\column{3cm}
		\begin{figure}
			\centering
			\pgfuseimage{kaleidoscope}
		\end{figure}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}{Linux system call debuggers and tracers on x86-64 architecture \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Alternative method of obtaining system call information}
\begin{itemize}
	\item Fetch the instruction pointer (PTRACE\_PEEKUSER RIP)
	\item {\bf Fetch the instruction (PTRACE\_PEEKTEXT rip-2)
	\item Determine the system call bitness by the opcode}
	\item Determine the system call by its number and bitness
	\item Fetch the system call arguments accordingly
\end{itemize}
\end{block}

\begin{block}{Drawbacks of the alternative method}
\begin{itemize}
	\item Easy to deceive the tracer
	\item The race condition between the instruction executed \\
		and the instruction fetched is inherent
	\item Extra ptrace system call invocation
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: surprise \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Compat 32-bit syscall entry from 64-bit task!?}
		\begin{itemize}
			\item If a tasks is set to 64 bit mode, but calls into the kernel via int 0x80
			it's changed to 32 bit mode for that system call and back to 64 bit mode
			when the system call is finished!?

			\item I think this behaviour is so unexpected that it can only cause security
			problems in the long run.

			\item Is anyone counting on this?

			\item Where is this behaviour documented?
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{indan} \\
			Indan \\ Zupancic
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/49017bd7edab7010cd9ac767e39d99e4.squirrel@webmail.greenhost.nl/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Abuse bits \#32 and \#33 of user\_regs\_struct.eflags}
		\begin{itemize}
			\item Using the high bits of 'eflags' might work.
			Hopefully nobody tests that.
			IOW, something like the attached might work.

			\item On a new kernel,
			bit \#32 of eflags will be set for a native 64-bit system call,
			and bit \#33 will be set for a compat system call.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{linus} \\
			Linus \\ Torvalds
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/CA+55aFzcSVmdDj9Lh_gdbz1OzHyEm6ZrGPBDAJnywm2LF_eVyg@mail.gmail.com/}
\url{https://lore.kernel.org/lkml/CA+55aFwMd8MMrcfG5f0zg=qjrBzUhgY1HgJx6QFcnpMQsW1PNg@mail.gmail.com/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Abuse bits [31:16] of CS}
		\begin{itemize}
			\item I would really like to not use a hack with the flags,
			because although there current aren't any flags in the high half of RFLAGS
			they are architecturally defined and could appear in the future.

			\item If we're going to use bits in an existing register field
			I would be happier if we used bits [31:16] of CS,
			which are unlikely to ever be used for anything.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{hpa} \\
			Hans Peter \\ Anvin
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/4F1731C1.4050007@zytor.com/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Add a new regset flavour with a pseudo-register}
		\begin{itemize}
			\item I do feel strongly that any new means of exposing bona fide user state
			ought to be done via the user\_regset mechanism.

			\item Either overloading some existing user\_regs\_struct bits
			if that truly is harmless to compatibility, or adding a new regset flavor.

			\item That way it is automatically recorded in core files,
			accessible with PTRACE\_GETREGSET, etc.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{roland} \\
			Roland \\ McGrath
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/CAB=4xhqW8RK2UpU5PPjSQo3nZYt8oZkaBf1VEhX37tbMVrAigg@mail.gmail.com/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Extend NT\_PRSTATUS regset}
		\begin{itemize}
			\item What about extending of one of the GETREGSET layouts?
			GETREGSET uses struct iovec. struct iovec has buf\_len.
			Currently, if buf\_len is larger than the register structure
			being requested, kernel simply returns less data than
			userspace asks for.

			\item In the x86 case, we can add additional field(s)
			at the end of NT\_PRSTATUS layout.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{denys} \\
			Denys \\ Vlasenko
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/CAK1hOcManWsEvjS2xxtfGTKx=JLPvO2sBkWU-xQP+medV=rbAA@mail.gmail.com/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Add PTRACE\_O\_TRACESYS\_VERY\_GOOD}
		\large
		\begin{itemize}
			\item Currently we have PTRACE\_O\_TRACESYSGOOD
			to avoid the confusion with the real SIGTRAP.
			Perhaps we can add PTRACE\_O\_TRACESYS\_VERY\_GOOD \\
			(or we can look at PT\_SEIZED instead)
			and report TS\_COMPAT via ptrace\_report\_syscall ?
			\item We can add the new events
			\begin{itemize}
				\item PTRACE\_EVENT\_SYSCALL\_ENTRY
				\item PTRACE\_EVENT\_SYSCALL\_COMPAT\_ENTRY
				\item PTRACE\_EVENT\_SYSCALL\_EXIT
				\item PTRACE\_EVENT\_SYSCALL\_COMPAT\_EXIT
			\end{itemize}
			\item This also allows to distinguish entry/exit.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{oleg} \\
			Oleg \\ Nesterov
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/20120125193635.GA30311@redhat.com/}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		{\large Early approaches to the problem: lively discussion in 2012}
		\begin{block}{Extend PTRACE\_GETEVENTMSG}
		\large
		\begin{itemize}
			\item Another idea, avoiding new PTRACE\_EVENTs per arch,
			would be to make the abi32/abi64/compat/whatnot discriminator
			retrievable with PTRACE\_GETEVENTMSG instead.

			\item So you'd get PTRACE\_EVENT\_SYSCALL\_ENTRY|EXIT,
			or the regular old 0x80|SIGTRAP, you'd still fetch the syscall number
			from \$orig\_ax (or whatever means for other archs), as usual,
			then have extra syscall info in PTRACE\_GETEVENTMSG.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{pedro} \\
			Pedro \\ Alves
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/4F210D9B.3030808@redhat.com/}
\end{frame}

%%%%%%%
%\begin{frame}{Process bitness does not match syscall bitness: early approaches \hfill [\insertframenumber/\inserttotalframenumber]}
%\Large
%\begin{block}{Early approaches to the problem: lively discussion in 2012}
%\begin{itemize}
%	\item Indan Zupancic: Compat 32-bit syscall entry from 64-bit task!?
%	\item Linus Torvalds: abuse bits \#32 and \#33 of eflags
%	\item H. Peter Anvin: abuse bits [31:16] of CS
%	\item Roland McGrath: add a new regset flavour with a pseudo-register
%	\item Denys Vlasenko: extend NT\_PRSTATUS regset
%	\item Oleg Nesterov: add PTRACE\_O\_TRACESYS\_VERY\_GOOD
%	\item Pedro Alves: extend PTRACE\_GETEVENTMSG
%	\item Andrew Lutomirski (2017): PTRACE\_GET\_SYSCALL\_INFO
%\end{itemize}
%\end{block}
%\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: problem evolution \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Pretend the problem does not exist}
Refuted by Debian bug report \#459820 submitted in 2008
\end{block}
\begin{block}{Argue the problem has no consequences}
Refuted by Indan Zupancic during seccomp discussion in 2012
\end{block}
\begin{block}{Claim the race is not practical}
Refuted by Linus Torvalds in the same discussion
\end{block}
\begin{block}{Suggest a lot of ideas}
Proved to be controversial during seccomp discussion in 2012
\end{block}
\begin{block}{Shrug and let those who care come up with patches}
None of kernel developers were interested enough \\
to implement a solution for the problem.
\end{block}
\end{frame}

%%%%%%%
\begin{frame}{Process bitness does not match syscall bitness: lasting idea \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{11cm}
		\begin{block}{08.03.2017: add PTRACE\_GET\_SYSCALL\_INFO}
		\large
		\begin{itemize}
			\item I am strongly opposed to fudging registers to half-arsedly
			slightly improve the epicly crappy ptrace(2) interface for syscalls.

			\item To fix this right, please just add PTRACE\_GET\_SYSCALL\_INFO or similar
			to, in one shot, read out all the syscall details.

			\item This means: arch, no, arg0..arg5, and whether it's entry or exit.

			\item I propose returning this structure because struct seccomp\_data already gets this right.
			There's plenty of opportunity to fine-tune this.
			Now it works on all architectures.
		\end{itemize}
		\end{block}
	\column{2.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{andy} \\
			Andrew \\ Lutomirski
		\end{figure}
\end{columns}
\bigskip
\tiny
\url{https://lore.kernel.org/lkml/CAObL_7GM0n80N7J_DFw_eQyfLyzq+sf4y2AvsCCV88Tb3AwEHA@mail.gmail.com/}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: first patch \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{columns}
	\column{8.2cm}
		Date: Wed, 7 Nov 2018 04:27:51 +0100 \\ \smallskip
		From: Elvira Khabirova <lineprinter@altlinux.org> \\ \smallskip
		Subject: [RFC PATCH] ptrace: add PTRACE\_GET\_SYSCALL\_INFO request \\ \bigskip
		{\tiny \url{https://lore.kernel.org/lkml/20181107042751.3b519062@akathisia/}}
	\column{3cm}
		\centerline{\pgfuseimage{lp}}
\end{columns}
\begin{columns}
\tiny
	\column{3.5cm}
\begin{alltt}
arch/alpha/kernel/ptrace.c      |  2 +-
arch/arc/kernel/ptrace.c        |  2 +-
arch/arm/kernel/ptrace.c        |  2 +-
arch/arm64/kernel/ptrace.c      |  2 +-
arch/c6x/kernel/ptrace.c        |  2 +-
arch/h8300/kernel/ptrace.c      |  2 +-
arch/hexagon/kernel/traps.c     |  2 +-
arch/ia64/kernel/ptrace.c       |  2 +-
arch/m68k/kernel/ptrace.c       |  3 ++-
arch/microblaze/kernel/ptrace.c |  2 +-
arch/mips/kernel/ptrace.c       |  2 +-
arch/nds32/kernel/ptrace.c      |  2 +-
arch/nios2/kernel/ptrace.c      |  3 ++-
arch/openrisc/kernel/ptrace.c   |  2 +-
arch/parisc/kernel/ptrace.c     |  2 +-
\end{alltt}
	\column{8cm}
\begin{alltt}
arch/powerpc/kernel/ptrace.c    |  2 +-
arch/riscv/kernel/ptrace.c      |  2 +-
arch/s390/kernel/ptrace.c       |  2 +-
arch/sh/kernel/ptrace_32.c      |  2 +-
arch/sh/kernel/ptrace_64.c      |  2 +-
arch/sparc/kernel/ptrace_32.c   |  2 +-
arch/sparc/kernel/ptrace_64.c   |  2 +-
arch/um/kernel/ptrace.c         |  2 +-
arch/x86/entry/common.c         |  2 +-
arch/xtensa/kernel/ptrace.c     |  2 +-
include/linux/ptrace.h          | 16 ++++++++++---
include/linux/tracehook.h       | 13 ++++++----
include/uapi/linux/ptrace.h     | 22 +++++++++++++++++
kernel/ptrace.c                 | 42 +++++++++++++++++++++++++++++++++
29 files changed, 113 insertions(+), 32 deletions(-)
\end{alltt}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: first patch: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{08.03.2017: Andy idea}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  __u8 pad0;
  __u16 pad1;
  __u32 pad2;
  union \{
    struct seccomp_data syscall_entry;
    __s64 syscall_exit_retval;
  \};
\};


struct seccomp_data \{
  int nr; \hfill /* syscall number */
  \textcolor{darkred}{__u32 arch; \hfill /* AUDIT_ARCH_* value */}
  __u64 instruction_pointer;
  __u64 args[6]; \hfill /* syscall args */
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{07.11.2018: first patch}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  __u8 __pad0[7];
  union \{
    struct \{
      __u64 nr; \hfill /* syscall number */
      __u64 ip;
      __u64 args[6]; \hfill /* syscall args */
      \textcolor{darkgreen}{__u8 is_compat; \hfill /* boolean value */}
      __u8 __pad1[7];
    \} entry_info;
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad2[7];
    \} exit_info;
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: second edition: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{07.11.2018: first edition}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  __u8 __pad0[7];
  union \{
    struct \{
      \textcolor{darkred}{__u64 nr; \hfill /* syscall number */}

      \textcolor{darkred}{__u64 ip;}
      __u64 args[6]; \hfill /* syscall args */
      \textcolor{darkred}{__u8 is_compat; \hfill /* boolean value */}
      \textcolor{darkred}{__u8 __pad1[7];}
    \} entry_info;
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad2[7];
    \} exit_info;
  \};
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{21.11.2018: second edition}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  __u8 __pad0[7];
  union \{
    struct \{
      \textcolor{darkgreen}{__s32 nr; \hfill /* syscall number */}
      \textcolor{darkgreen}{__u32 arch; \hfill /* AUDIT_ARCH_* value */}
      \textcolor{darkgreen}{__u64 instruction_pointer;}
      __u64 args[6]; \hfill /* syscall args */


    \} entry_info;
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad1[7];
    \} exit_info;
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}{Add PTRACE\_GET\_SYSCALL\_INFO: second edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{20.11.2018: second edition, part 1}
\begin{itemize}
	\item v2 00/16: Prepare for PTRACE\_GET\_SYSCALL\_INFO
	\begin{itemize}
		\scriptsize
		\item Move EM\_HEXAGON to uapi/linux/elf-em.h
		\item Move EM\_ARCOMPACT and EM\_ARCV2 to uapi/linux/elf-em.h
		\item Move EM\_UNICORE to uapi/linux/elf-em.h
		\item elf-em.h: add EM\_NDS32
		\item elf-em.h: add EM\_XTENSA
		\item m68k: define syscall\_get\_arch()
		\item arc: define syscall\_get\_arch()
		\item c6x: define syscall\_get\_arch()
		\item h8300: define syscall\_get\_arch()
		\item hexagon: define syscall\_get\_arch()
		\item nds32: define syscall\_get\_arch()
		\item nios2: define syscall\_get\_arch()
		\item riscv: define syscall\_get\_arch()
		\item unicore32: define syscall\_get\_arch()
		\item \textcolor{darkgreen}{xtensa: define syscall\_get\_arch()}
		\item syscall\_get\_arch: add "struct task\_struct *" argument
	\end{itemize}
	\item \textcolor{darkgreen}{mips: fix mips\_get\_syscall\_arg o32 check}
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: second edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{21.11.2018: second edition, part 2}
\large
\begin{columns}
	\column{8.5cm}
\begin{itemize}
	\item RFC PATCH v2: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
\begin{alltt}
\scriptsize
include/linux/ptrace.h      |  8 ++++++
include/linux/tracehook.h   |  9 ++++--
include/uapi/linux/ptrace.h | 20 +++++++++++++
kernel/ptrace.c             | 56 +++++++++++++++++++++++++++++++++++++
4 files changed, 90 insertions(+), 3 deletions(-)
\end{alltt}
\end{itemize}
	\column{4.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{lp} \\
			Elvira Khabirova
		\end{figure}
\end{columns}
\bigskip
\begin{itemize}
	\item v3: powerpc/ptrace: replace ptrace\_report\_syscall() with a tracehook call
	\item \textcolor{darkgreen}{x86/ptrace: Fix documentation for tracehook\_report\_syscall\_entry()}
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: third edition: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{21.11.2018: second edition}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  \textcolor{darkred}{__u8 __pad0[7];}

  union \{
    struct \{
      \textcolor{darkred}{__s32 nr; \hfill /* syscall number */}
      \textcolor{darkred}{__u32 arch; \hfill /* AUDIT_ARCH_* value */}
      __u64 instruction_pointer;


      __u64 args[6]; \hfill /* syscall args */
    \textcolor{darkred}{\} entry_info;}
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad1[7];
    \textcolor{darkred}{\} exit_info;}
  \};
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{25.11.2018: third edition}
\begin{alltt}
\scriptsize
struct ptrace_syscall_info \{
  __u8 op; \hfill /* 0 for entry, 1 for exit */
  \textcolor{darkgreen}{__u8 __pad0[3];}
  \textcolor{darkgreen}{__u32 arch; \hfill /* AUDIT_ARCH_* value */}
  union \{
    struct \{
      \textcolor{darkgreen}{__u64 nr; \hfill /* syscall number */}

      __u64 instruction_pointer;
      \textcolor{darkgreen}{__u64 stack_pointer;}
      \textcolor{darkgreen}{__u64 frame_pointer;}
      __u64 args[6]; \hfill /* syscall args */
    \textcolor{darkgreen}{\} entry;}
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad1[7];
    \textcolor{darkgreen}{\} exit;}
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: third edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{25.11.2018: third edition}
\large
\begin{columns}
	\column{8.5cm}
\begin{itemize}
	\item v3 0/3: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\begin{itemize}
		\item ptrace: pass the type of syscall-stop in ptrace\_message
		\item ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
		\item ptrace: add PTRACE\_EVENT\_SECCOMP support to PTRACE\_GET\_SYSCALL\_INFO
	\end{itemize}
\end{itemize}
	\column{4.5cm}
		\begin{figure}
			\centering
			\pgfuseimage{lp} \\
			Elvira Khabirova
		\end{figure}
\end{columns}
\begin{alltt}
\scriptsize
 include/linux/ptrace.h      |  1 +
 include/linux/sched.h       |  1 +
 include/linux/tracehook.h   | 10 ++++---
 include/uapi/linux/ptrace.h | 34 ++++++++++++++++++++++++
 kernel/ptrace.c             | 53 +++++++++++++++++++++++++++++++++++++
 5 files changed, 96 insertions(+), 3 deletions(-)
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: 4th edition: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{25.11.2018: third edition}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  \textcolor{darkred}{__u8 op; \hfill /* 0 for entry, 1 for exit */}
  __u8 __pad0[3];
  __u32 arch; \hfill /* AUDIT_ARCH_* value */
  union \{
    struct \{
      __u64 nr; \hfill /* syscall number */
      __u64 instruction_pointer;
      __u64 stack_pointer;
      __u64 frame_pointer;
      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    struct \{
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad1[7];
    \} exit;









  \};
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{28.11.2018: 4th edition}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  \textcolor{darkgreen}{__u8 op; \hfill /* PTRACE_SYSCALL_INFO_* */}
  __u8 __pad0[3];
  __u32 arch; \hfill /* AUDIT_ARCH_* value */
  union \{
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr; \hfill /* syscall number */
      __u64 instruction_pointer;
      __u64 stack_pointer;
      __u64 frame_pointer;
      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_EXIT */
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      __u8 __pad1[7];
    \} exit;
    \textcolor{darkgreen}{struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */}
      \textcolor{darkgreen}{__u64 nr; \hfill /* syscall number */}
      \textcolor{darkgreen}{__u64 instruction_pointer;}
      \textcolor{darkgreen}{__u64 stack_pointer;}
      \textcolor{darkgreen}{__u64 frame_pointer;}
      \textcolor{darkgreen}{__u64 args[6]; \hfill /* syscall args */}
      \textcolor{darkgreen}{__u32 ret_data; \hfill /* SECCOMP_RET_DATA */}
      \textcolor{darkgreen}{__u8 __pad2[4];}
    \textcolor{darkgreen}{\} seccomp;}
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: 5th edition: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{28.11.2018: 4th edition}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  __u8 op; \hfill /* PTRACE_SYSCALL_INFO_* */
  __u8 __pad0[3];
  __u32 arch; \hfill /* AUDIT_ARCH_* value */



  union \{
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr; \hfill /* syscall number */
      \textcolor{darkred}{__u64 instruction_pointer;}
      \textcolor{darkred}{__u64 stack_pointer;}
      \textcolor{darkred}{__u64 frame_pointer;}
      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    \ldots
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */
      __u64 nr; \hfill /* syscall number */
      \textcolor{darkred}{__u64 instruction_pointer;}
      \textcolor{darkred}{__u64 stack_pointer;}
      \textcolor{darkred}{__u64 frame_pointer;}
      __u64 args[6]; \hfill /* syscall args */
      __u32 ret_data; \hfill /* SECCOMP_RET_DATA */
      __u8 __pad2[4];
    \} seccomp;
  \};
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{10.12.2018: 5th edition}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  __u8 op; \hfill /* PTRACE_SYSCALL_INFO_* */
  __u8 __pad0[3];
  __u32 arch; \hfill /* AUDIT_ARCH_* value */
  \textcolor{darkgreen}{__u64 instruction_pointer;}
  \textcolor{darkgreen}{__u64 stack_pointer;}
  \textcolor{darkgreen}{__u64 frame_pointer;}
  union \{
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr; \hfill /* syscall number */



      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    \ldots
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */
      __u64 nr; \hfill /* syscall number */



      __u64 args[6]; \hfill /* syscall args */
      __u32 ret_data; \hfill /* SECCOMP_RET_DATA */
      __u8 __pad2[4];
    \} seccomp;
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}{Add PTRACE\_GET\_SYSCALL\_INFO: 5th edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\scriptsize
\begin{block}{03.12.2018 -- 10.12.2018: 5th edition}
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\item ia64: fix syscall\_get\_error()
	\item microblaze: fix syscall\_set\_return\_value()
	\item nios2: fix syscall\_get\_error()
	\item sh: fix syscall\_set\_return\_value()
	\item \textcolor{darkgreen}{selftests: do not macro-expand failed assertion expressions}
	\item \textcolor{darkgreen}{v5: powerpc/ptrace: replace ptrace\_report\_syscall() with a tracehook call}
	\item v5 00/25: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\setlength{\itemsep}{0pt}
	\begin{columns}
		\column{6cm}
			\begin{itemize}
				\tiny
				\setlength{\itemsep}{0pt}
				\item alpha: define remaining syscall\_get\_* functions
				\item Move EM\_ARCOMPACT and EM\_ARCV2 to \\ uapi/linux/elf-em.h
				\item arc: define syscall\_get\_arch()
				\item c6x: define syscall\_get\_arch()
				\item elf-em.h: add EM\_CSKY
				\item csky: define syscall\_get\_arch()
				\item h8300: define remaining syscall\_get\_* functions
				\item Move EM\_HEXAGON to uapi/linux/elf-em.h
				\item hexagon: define remaining syscall\_get\_* functions
				\item Move EM\_NDS32 to uapi/linux/elf-em.h
				\item nds32: define syscall\_get\_arch()
				\item nios2: define syscall\_get\_arch()
			\end{itemize}
		\column{7cm}
			\begin{itemize}
				\tiny
				\setlength{\itemsep}{0pt}
				\item m68k: add asm/syscall.h
				\item mips: define syscall\_get\_error()
				\item parisc: define syscall\_get\_error()
				\item powerpc: define syscall\_get\_error()
				\item riscv: define syscall\_get\_arch()
				\item Move EM\_XTENSA to uapi/linux/elf-em.h
				\item xtensa: define syscall\_get\_* functions
				\item Move EM\_UNICORE to uapi/linux/elf-em.h
				\item unicore32: add asm/syscall.h
				\item syscall\_get\_arch: add "struct task\_struct *" argument
				\smallskip \hrule
				\item ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
				\item selftests/ptrace: add a test case for \\ PTRACE\_GET\_SYSCALL\_INFO
			\end{itemize}
	\end{columns}
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: 6th edition: API \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{10.12.2018: 5th edition}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  __u8 op; \hfill /* PTRACE_SYSCALL_INFO_* */
  \textcolor{darkred}{__u8 __pad0[3];}
  \textcolor{darkred}{__u32 arch; \hfill /* AUDIT_ARCH_* value */}
  __u64 instruction_pointer;
  __u64 stack_pointer;
  \textcolor{darkred}{__u64 frame_pointer;}
  union \{
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr; \hfill /* syscall number */
      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_EXIT */
      __s64 rval; \hfill /* return value */
      __u8 is_error;
      \textcolor{darkred}{__u8 __pad1[7];}
    \} exit;
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */
      __u64 nr; \hfill /* syscall number */
      __u64 args[6]; \hfill /* syscall args */
      __u32 ret_data; \hfill /* SECCOMP_RET_DATA */
      \textcolor{darkred}{__u8 __pad2[4];}
    \} seccomp;
  \};
\};
\end{alltt}
		\end{block}
	\column{6.5cm}
		\begin{block}{13.12.2018: 6th edition (final)}
\begin{alltt}
\tiny
struct ptrace_syscall_info \{
  __u8 op; \hfill /* PTRACE_SYSCALL_INFO_* */

  \textcolor{darkgreen}{__aligned_u32 arch; \hfill /* AUDIT_ARCH_* value */}
  __u64 instruction_pointer;
  __u64 stack_pointer;

  union \{
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr; \hfill /* syscall number */
      __u64 args[6]; \hfill /* syscall args */
    \} entry;
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_EXIT */
      __s64 rval; \hfill /* return value */
      __u8 is_error;

    \} exit;
    struct \{ \hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */
      __u64 nr; \hfill /* syscall number */
      __u64 args[6]; \hfill /* syscall args */
      __u32 ret_data; \hfill /* SECCOMP_RET_DATA */

    \} seccomp;
  \};
\};
\end{alltt}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}{Add PTRACE\_GET\_SYSCALL\_INFO: 6th edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{13.12.2018: 6th edition (API finalized)}
\large
\begin{itemize}
	\setlength{\itemsep}{0pt}
	\item v6 00/26: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\begin{columns}
		\column{6cm}
			\begin{itemize}
				\tiny
				\setlength{\itemsep}{0pt}
				\item asm-generic/syscall.h: prepare for inclusion by other files
				\item asm-generic/syscall.h: turn syscall\_[gs]et\_arguments into wrappers
				\item alpha: define remaining syscall\_get\_* functions
				\item Move EM\_ARCOMPACT and EM\_ARCV2 to uapi/linux/elf-em.h
				\item arc: define syscall\_get\_arch()
				\item c6x: define syscall\_get\_arch()
				\item \textcolor{darkgreen}{elf-em.h: add EM\_CSKY}
				\item \textcolor{darkgreen}{csky: define syscall\_get\_arch()}
				\item h8300: define remaining syscall\_get\_* functions
				\item Move EM\_HEXAGON to uapi/linux/elf-em.h
				\item hexagon: define remaining syscall\_get\_* functions
				\item Move EM\_NDS32 to uapi/linux/elf-em.h
			\end{itemize}
		\column{7cm}
			\begin{itemize}
				\tiny
				\setlength{\itemsep}{0pt}
				\item nds32: define syscall\_get\_arch()
				\item nios2: define syscall\_get\_arch()
				\item m68k: add asm/syscall.h
				\item mips: define syscall\_get\_error()
				\item parisc: define syscall\_get\_error()
				\item powerpc: define syscall\_get\_error()
				\item riscv: define syscall\_get\_arch()
				\item \textcolor{darkgreen}{Move EM\_XTENSA to uapi/linux/elf-em.h}
				\item \textcolor{darkgreen}{xtensa: define syscall\_get\_* functions}
				\item Move EM\_UNICORE to uapi/linux/elf-em.h
				\item unicore32: add asm/syscall.h
				\item syscall\_get\_arch: add "struct task\_struct *" argument
				\item ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
				\item selftests/ptrace: add a test case for PTRACE\_GET\_SYSCALL\_INFO
			\end{itemize}
	\end{columns}
	\item \textcolor{darkgreen}{powerpc/ptrace: Combine SYSCALL\_EMU \& SYSCALL\_TRACE handling}
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: 7th edition: patches \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{block}{07.01.2019: 7th edition: rebased to v5.0-rc1, no changes}
\begin{itemize}
	\item v7 00/22: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
\begin{columns}
\tiny
	\column{4.5cm}
\begin{alltt}
arch/alpha/include/asm/syscall.h      |  31 +-
arch/arc/include/asm/elf.h            |   6 +-
arch/arc/include/asm/syscall.h        |  11 +
arch/arm/include/asm/syscall.h        |   2 +-
arch/arm64/include/asm/syscall.h      |   4 +-
arch/c6x/include/asm/syscall.h        |   7 +
arch/csky/include/asm/syscall.h       |   2 +-
arch/h8300/include/asm/syscall.h      |  19 ++
arch/hexagon/include/asm/elf.h        |   6 +-
arch/hexagon/include/asm/syscall.h    |  22 ++
arch/ia64/include/asm/syscall.h       |   2 +-
arch/m68k/include/asm/syscall.h       |  42 +++
arch/microblaze/include/asm/syscall.h |   2 +-
arch/mips/include/asm/syscall.h       |  12 +-
arch/mips/kernel/ptrace.c             |   2 +-
arch/nds32/include/asm/elf.h          |   3 +-
arch/nds32/include/asm/syscall.h      |   8 +
arch/nios2/include/asm/syscall.h      |   6 +
arch/openrisc/include/asm/syscall.h   |   2 +-
arch/parisc/include/asm/syscall.h     |  11 +-
arch/powerpc/include/asm/syscall.h    |  20 +-
arch/riscv/include/asm/syscall.h      |  10 +
arch/s390/include/asm/syscall.h       |   4 +-
\end{alltt}
	\column{8cm}
\begin{alltt}
arch/sh/include/asm/syscall_32.h              |   2 +-
arch/sh/include/asm/syscall_64.h              |   2 +-
arch/sparc/include/asm/syscall.h              |   5 +-
arch/unicore32/include/asm/elf.h              |   3 +-
arch/unicore32/include/asm/syscall.h          |  47 +++
arch/x86/include/asm/syscall.h                |   8 +-
arch/x86/um/asm/syscall.h                     |   2 +-
arch/xtensa/include/asm/syscall.h             |   2 +-
include/asm-generic/syscall.h                 |  85 ++++--
include/linux/tracehook.h                     |   9 +-
include/uapi/linux/audit.h                    |  14 +
include/uapi/linux/elf-em.h                   |   6 +
include/uapi/linux/ptrace.h                   |  35 +++
kernel/auditsc.c                              |   4 +-
kernel/ptrace.c                               | 101 ++++++-
kernel/seccomp.c                              |   4 +-
tools/testing/selftests/ptrace/.gitignore     |   1 +
tools/testing/selftests/ptrace/Makefile       |   2 +-
.../selftests/ptrace/get_syscall_info.c       | 271 ++++++++++++++++++
42 files changed, 771 insertions(+), 66 deletions(-)
create mode 100644 arch/m68k/include/asm/syscall.h
create mode 100644 arch/unicore32/include/asm/syscall.h
create mode 100644 tools/testing/selftests/ptrace/get_syscall_info.c
\end{alltt}
\end{columns}
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: 7th edition: conslusion \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{block}{\Large 07.01.2019: 7th edition: rebased to v5.0-rc1, no changes}
\begin{itemize}
	\item v7 00/22: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\item 4 arch-specific preparatory patches have been merged into v5.0-rc1
		via corresponding arch trees
	\item Fundamentally failed to build on Alpha architecture
	\item Changes two different subsystems: audit and ptrace
	\item Changes every architecture
\end{itemize}
\end{block}
\begin{block}{\Large 07.01.2019: 7th edition: conslusion}
\begin{itemize}
	\item Those few niche architectures without CONFIG\_HAVE\_ARCH\_TRACEHOOK do not worth the effort
	\item Too big and diverse to be accepted as a whole
	\item Divide and conquer
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Add PTRACE\_GET\_SYSCALL\_INFO: divide \hfill [\insertframenumber/\inserttotalframenumber]}
\Large
\begin{columns}
	\column{6.5cm}
		\begin{block}{1. Push via audit tree}
	\begin{itemize}
		\scriptsize
		\item Move EM\_ARCOMPACT and EM\_ARCV2 to uapi/linux/elf-em.h
		\item arc: define syscall\_get\_arch()
		\item c6x: define syscall\_get\_arch()
		\item h8300: define syscall\_get\_arch()
		\item Move EM\_HEXAGON to uapi/linux/elf-em.h
		\item hexagon: define syscall\_get\_arch()
		\item m68k: define syscall\_get\_arch()
		\item Move EM\_NDS32 to uapi/linux/elf-em.h
		\item nds32: define syscall\_get\_arch()
		\item nios2: define syscall\_get\_arch()
		\item \textcolor{darkgreen}{riscv: define syscall\_get\_arch()}
		\item Move EM\_UNICORE to uapi/linux/elf-em.h
		\item unicore32: define syscall\_get\_arch()
		\item \textbf{syscall\_get\_arch: \\ add "struct task\_struct *" argument}
	\end{itemize}
		\end{block}
	\column{6.5cm}
		\begin{columns}
			\column{3cm}
				\begin{figure}
					\centering
					\scriptsize
					\pgfuseimage{paul} \\
					Paul Moore
				\end{figure}
			\column{3cm}
				\begin{figure}
					\centering
					\scriptsize
					\pgfuseimage{andrew} \\
					Andrew Morton
				\end{figure}
		\end{columns}
		\begin{block}{2. Push via -mm patch queue}
	\begin{itemize}
		\scriptsize
		\item nds32: fix asm/syscall.h
		\item hexagon: define syscall\_get\_error() and syscall\_get\_return\_value()
		\item mips: define syscall\_get\_error()
		\item parisc: define syscall\_get\_error()
		\item powerpc: define syscall\_get\_error()
		\item \textbf{ptrace: add PTRACE\_GET\_SYSCALL\_INFO request}
		\item selftests/ptrace: add a test case for PTRACE\_GET\_SYSCALL\_INFO
	\end{itemize}
		\end{block}
\end{columns}
\end{frame}

%%%%%%%
\begin{frame}{Add PTRACE\_GET\_SYSCALL\_INFO: audit tree \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{block}{\Large Push syscall\_get\_arch change via audit tree}
\begin{itemize}
	\item \textcolor{darkred}{06.01.2019: v5.0-rc1 tagged, merge window closed}
	\item 09.01.2019: 00/14 Prepare syscall\_get\_arch \\ for PTRACE\_GET\_SYSCALL\_INFO
	\item Pinging, got Acked-by for 2 of 5 architectures
	\item \textcolor{darkgreen}{03.03.2019: v5.0 released, merge window opened}
	\item \textcolor{darkred}{17.03.2019: v5.1-rc1 tagged, merge window closed}
	\item 18.03.2019: v2 00/13: Prepare syscall\_get\_arch \\ for PTRACE\_GET\_SYSCALL\_INFO
	\item 20.03.2019: Merged into audit/next
	\item \textcolor{darkgreen}{05.05.2019: v5.1 released, merge window opened}
	\item 08.05.2019: Merged via audit tree by commit v5.2-rc1$\sim$144
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}{Add PTRACE\_GET\_SYSCALL\_INFO: final push \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{block}{\Large Push PTRACE\_GET\_SYSCALL\_INFO via -mm patch queue}
\begin{itemize}
	\item \textcolor{darkred}{17.03.2019: v5.1-rc1 tagged, merge window closed}
	\item 20.03.2019: \textit{syscall\_get\_arch change merged into audit/next}
	\item 22.03.2019: v8 0/7: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\item 08.04.2019: v9 0/7: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\item 16.04.2019: v10 0/7: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\item \textcolor{darkgreen}{05.05.2019: v5.1 released, merge window opened}
	\item 08.05.2019: \textit{syscall\_get\_arch change merged via audit tree}
	\item 10.05.2019: v11 0/7: ptrace: add PTRACE\_GET\_SYSCALL\_INFO request
	\item \textcolor{darkred}{19.05.2019: v5.2-rc1 tagged, merge window closed}
	\item 22.05.2019: Added to -mm patch queue
	\item \textcolor{darkgreen}{07.07.2019: v5.2 released, merge window opened}
	\item 17.07.2019: Merged via -mm patch queue, last commit is v5.3-rc1$\sim$65{\textasciicircum}2$\sim$22
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: result \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{block}{\large PTRACE\_GET\_SYSCALL\_INFO: strace >= v4.26, linux >= v5.3-rc1}
\begin{verbatim}
$ git log -i -E --author=altlinux.org \
  --grep='ptrace|syscall_a|elf-em|selftests' v4.20-rc2..v5.3-rc1
\end{verbatim}
\large
\begin{itemize}
	\item 29 commits, 47 files changed, 703 insertions, 125 deletions
	\item 2 authors: Elvira Khabirova, Dmitry Levin
	\item 22 persons added their Acked-by/Reviewed-by/Signed-off-by
	\item 07.11.2018: first RFC patch submitted
	\item 12.11.2018: first patch committed
	\item 13.12.2018: API finalized
	\item 17.07.2019: last patch committed
	\item Implements PTRACE\_GET\_SYSCALL\_INFO on those 19 architectures \\
		that enable CONFIG\_HAVE\_ARCH\_TRACEHOOK
\end{itemize}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: API \hfill [\insertframenumber/\inserttotalframenumber]}
\begin{block}{Extends ptrace with PTRACE\_GET\_SYSCALL\_INFO request}
\scriptsize
\begin{alltt}
struct ptrace_syscall_info \{
  __u8 op;			\hfill /* Type of system call stop */
  \textcolor{darkgreen}{__aligned_u32 arch;	\hfill /* AUDIT_ARCH_* value; see seccomp(2) */}
  __u64 instruction_pointer;	\hfill /* CPU instruction pointer */
  __u64 stack_pointer;		\hfill /* CPU stack pointer */
  union \{
    struct \{			\hfill /* op == PTRACE_SYSCALL_INFO_ENTRY */
      __u64 nr;			\hfill /* System call number */
      __u64 args[6];		\hfill /* System call arguments */
    \} entry;
    struct \{			\hfill /* op == PTRACE_SYSCALL_INFO_EXIT */
      __s64 rval;		\hfill /* System call return value */
      __u8 is_error;		\hfill /* System call error boolean: does rval contain an error value? */
    \} exit;
    struct \{			\hfill /* op == PTRACE_SYSCALL_INFO_SECCOMP */
      __u64 nr;			\hfill /* System call number */
      __u64 args[6];		\hfill /* System call arguments */
      __u32 ret_data;		\hfill /* SECCOMP_RET_DATA portion of SECCOMP_RET_TRACE return value */
    \} seccomp;
  \};
\};
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{Process bitness does not match syscall bitness: no longer a problem \hfill [\insertframenumber/\inserttotalframenumber]}
\large
\begin{block}{Example based on Debian bug report \#459820 submitted in 2008}
\begin{alltt}
#include <stdio.h>
#include <unistd.h>
int main() \{
    setlinebuf(stdout);
    puts("------------");
    \textcolor{darkred}{__asm__("movl $2, %eax; int $0x80");}
    printf("[I am %d]{\textbackslash}n", getpid());
    return 0;
\}
\end{alltt}
\end{block}

\begin{block}{Regular invocation: ./debbug459820}
\begin{alltt}
------------
[I am 23450]
[I am 23451]
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
\begin{frame}[fragile]{PTRACE\_GET\_SYSCALL\_INFO: strace >= v4.26, linux >= v5.3-rc1}
\large
\begin{block}{Invocation under strace: strace -f -z ./debbug459820 > /dev/null}
\begin{alltt}
\ldots
write(1, "------------{\textbackslash}n", 13)          = 13
\textcolor{darkred}{strace: [ Process PID=23450 runs in 32 bit mode. ]}
strace: Process 23451 attached
fork()                                  = 23451
\textcolor{darkred}{strace: [ Process PID=23450 runs in 64 bit mode. ]}
[pid 23450] getpid()                    = 23450
\textcolor{darkred}{strace: [ Process PID=23451 runs in 64 bit mode. ]}
[pid 23451] getpid()                    = 23451
[pid 23450] write(1, "[I am 23450]{\textbackslash}n", 13) = 13
[pid 23451] write(1, "[I am 23451]{\textbackslash}n", 13) = 13
[pid 23450] +++ exited with 0 +++
+++ exited with 0 +++
\end{alltt}
\end{block}
\end{frame}

%%%%%%%
{
\setbeamertemplate{footline}{}
\begin{frame}[noframenumbering]{Questions?}
	\begin{columns}
		\column{4cm}
			\centerline{\pgfuseimage{linux-logo}}
		\column{3cm}
		\column{3cm}
			\centerline{\pgfuseimage{strace-logo}}
	\end{columns}
\end{frame}
}

\end{document}
